#! /bin/awk -f

BEGIN {
    FS = "\t"
    codepoint = -1
    codepoint_max = -1
    codepoint_count = 0
}

$1 ~ /^[0-9A-F][0-9A-F]*$/ {
    codepoint = mystrtonum("0x" $1)
    uniname[codepoint] = $2
    uniannot_size[codepoint] = 0
    if (codepoint_max < codepoint)
        codepoint_max = codepoint
    codepoint_count++
}

$1 ~ /^$/ && 0 <= codepoint {
    uniannot[codepoint][uniannot_size[codepoint]] = $2
    uniannot_size[codepoint]++
}

0 <= codepoint {
    codepoint = 0
}

END {
    printf("/* This file is generated by an Awk program. */\n\n")
    printf("#include \"uninameslookup_internal.h\"\n\n")
    print_codepoint_count(codepoint_count)
    print_codepoint_array(uniname, codepoint_max, codepoint_count)
    print_uniname_array(uniname, codepoint_max, codepoint_count)
    print_uniannot_array(uniannot_size, uniannot, codepoint_max, codepoint_count)
}

function print_codepoint_count(codepoint_count)
{
    printf("const int codepoint_count_ = %d;\n\n", codepoint_count)
}

function print_codepoint_array(some_unilist, i_max, size)
{
    printf("const int codepoints_[%d] = {", size)
    j = -1
    separator = ""
    for (i = 0; i <= i_max; i++) {
        if (i in some_unilist) {
            j++
            if (j == 10) {
                j = 0
                separator = separator "\n"
            }
            printf("%s%d", separator, i)
            separator = ","
        }
    }
    printf "};\n\n"
}

function print_uniname_array(uniname, i_max, size)
{
    printf("const char *uniname_[%d] = {", size)
    separator = "\n"
    for (i = 0; i <= i_max; i++) {
        if (i in uniname) {
            printf("%s%s", separator, wrap_for_gettext(uniname[i]))
            separator = ",\n"
        }
    }
    printf "\n};\n\n"
}

function print_uniannot_array(uniannot_size, uniannot, i_max, size)
{
    printf("const char *uniannot_[%d] = {", size)
    separator = "\n"
    for (i = 0; i <= i_max; i++) {
        if (i in uniname) {
            prefix = "\t"
            s = ""
            for (j = 0; j < uniannot_size[i]; j++) {
                s = s prefix uniannot[i][j]
                prefix = "\n\t"
            }
            printf("%s%s", separator, wrap_for_gettext(s))
            separator = ",\n"
        }
    }
    printf "\n};\n\n"
}

function wrap_for_gettext(s)
{
    if (s == "")
        t = "\"\""
    else
        t = "N_(\"" escape_for_c(s) "\")"
    return t
}   

function escape_for_c(s)
{
    gsub(/\\/, "\\\\", s)
    gsub(/"/, "\\\"", s)
    gsub(/\n/, "\\n", s)
    gsub(/\t/, "\\t", s)
    gsub(/æ/, "<<ae>>", s)
    gsub(/ð/, "<<eth>>", s)
    gsub(/·/, "<<dot>>", s)
    gsub(/ä/, "<<adieresis>>", s)
    gsub(/Å/, "<<Aring>>", s)
    gsub(/é/, "<<eacute>>", s)
    gsub(/è/, "<<egrave>>", s)
    gsub(/ö/, "<<odieresis>>", s)
    gsub(/ü/, "<<udieresis>>", s)
    gsub(/´/, "<<prime>>", s)
    return s
}

# Suggested by the GNU Awk manual as a substitute for that Awk's
# strtonum() function, if the actual Awk does not have it built in.
function mystrtonum(str, ret, chars, n, i, k, c)
{
    if (str ~ /^0[0-7]*$/) {
        # octal
        n = length(str)
        ret = 0
        for (i = 1; i <= n; i++) {
            c = substr(str, i, 1)
            if ((k = index("01234567", c)) > 0)
                k-- # adjust for 1-basing in awk
     
            ret = ret * 8 + k
        }
    } else if (str ~ /^0[xX][[:xdigit:]]+/) {
        # hexadecimal
        str = substr(str, 3)    # lop off leading 0x
        n = length(str)
        ret = 0
        for (i = 1; i <= n; i++) {
            c = substr(str, i, 1)
            c = tolower(c)
            if ((k = index("0123456789", c)) > 0)
                k-- # adjust for 1-basing in awk
            else if ((k = index("abcdef", c)) > 0)
                k += 9
     
            ret = ret * 16 + k
        }
    } else if (str ~ \
               /^[-+]?([0-9]+([.][0-9]*([Ee][0-9]+)?)?|([.][0-9]+([Ee][-+]?[0-9]+)?))$/) {
        # decimal number, possibly floating point
        ret = str + 0
    } else
        ret = "NOT-A-NUMBER"
     
    return ret
}
